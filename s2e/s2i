#!/bin/bash
#cicd toolset
#author: jimin.huang
#email: jimin.huang@benload.com
#email: jimminh@163.com
set -e

###################################################################
THIS_SCRIPT=$(realpath $(cd "$(dirname "${BASH_SOURCE:-$0}")"; pwd)/$(basename ${BASH_SOURCE:-$0}))
#automatic detection TOPDIR
SCRIPT_DIR=$(dirname $(realpath ${THIS_SCRIPT}))

USAGE="
  usage:
  A cicd tool, from src to artifact, to docker img, deploy into kubernetes:
  I. default do all action(artifact,docker,deploy):
  $(basename $(realpath $0)) /path/to/srctop

  II. only do specify action:
  $(basename $(realpath $0)) /path/to/srctop [ analysis|artifact|docker|deploy|deploy-update-blue ]

    1. only do artifact
    $(basename $(realpath $0)) /path/to/srctop artifact

    2. only do docker build push
    export DOCKER_REPO=harbor.benload.com
    export DOCKER_NS=bu5
    $(basename $(realpath $0)) /path/to/srctop docker

    3. only do kubernetes deploy
    export K8S_KUBECONFIG=/root/.kube/config
    export K8S_NS_SUFFIX=-dev
    export K8S_NS=default
    export K8S_DOMAIN_INTERNAL=benload.cn
    export K8S_DOMAIN_PUBLIC=bu5-dev.tx
    export INGRESS_INTERNAL_ENABLED=1
    export INGRESS_PUBLIC_ENABLED=1
    export INGRESS_CLASS_INTERNAL=nginx
    export INGRESS_CLASS_PUBLIC=nginx
    $(basename $(realpath $0)) /path/to/srctop deploy

  III. do exec cmd:
  $(basename $(realpath $0)) /path/to/rundir exec wrappercmd [...]
    1. do ls on /root directory
    $(basename $(realpath $0)) /root ls
"

if [[ $# -lt 1 ]];then
    echo "${USAGE}"
    exit 1
else
    SRC_TOP=$(realpath $1)
fi

if [[ $# -gt 1 ]];then
    ACTION_STAGE=$2
else
    ACTION_STAGE="ACTION_ALL"
fi
if [[ -z ${CI_PROJECT_PATH} ]];then
  CI_PROJECT_PATH="$(git rev-parse --show-toplevel)/"
fi
if [[ -z ${CI_PROJECT_PATH} ]];then
CUR_DIR=$(pwd)
CI_PROJECT_PATH=$(xdir=${CUR_DIR};cd ${CUR_DIR}; while /usr/bin/test ! -d .git ; do \
        xdir=`cd ../;pwd`;                       \
        if [ "$xdir" = "/" ] ; then             \
           echo  1>&2;                          \
           cd ${CUR_DIR}                        \
           break;                               \
        fi ;                                    \
        cd $xdir;                               \
        pwd;                                    \
        done)
fi
DEFAULT_NS="${S2E_ORG}${S2E_NS}"
if [[ "" == ${DEFAULT_NS} ]];then
    DEFAULT_NS="$(echo ${CI_PROJECT_PATH} | perl -ne 's@^\/@@;print' | awk -F"/" '{print $1$2}')"
fi
if [[ "" == ${DEFAULT_NS} ]];then
    DEFAULT_NS="default"
fi
echo "SRC_TOP=${SRC_TOP}"
echo "CI_PROJECT_PATH=${CI_PROJECT_PATH}"
echo "DEFAULT_NS=${DEFAULT_NS}"
S2I_REPORT_DIR=$(git rev-parse --show-toplevel)/.s2i
mkdir -p ${S2I_REPORT_DIR}

cd ${SRC_TOP}
function do_src_get_srctype_by_topdir()
{
    echo "$FUNCNAME"
    # try to guest java or nodejs, ...
    echo "try to detect java/nodejs source"
    DETECT_JAVA="find ${SRC_TOP} -maxdepth 1 -iname pom.xml"
    DETECT_NODEJS="find ${SRC_TOP} -maxdepth 1 -iname package.json"
    DETECT_DEFAULT_TOP="find ${SRC_TOP}   -maxdepth 1 -iname .TOP"
    DETECT_DEFAULT_GIT="find ${SRC_TOP}   -maxdepth 1 -iname .git"
    eval ${DETECT_JAVA}
    eval ${DETECT_NODEJS}
    if [[ -n $(eval ${DETECT_JAVA}) ]];then
        pom=`echo $(eval ${DETECT_JAVA}) | head -n 1`
#        SRC_TOP=`echo $(realpath $(dirname ${pom})) | sort | head -n 1`
        SRC_TYPE=java
        echo "SRC_TYPE=${SRC_TYPE}"
        #mvn --file ${SRC_TOP} -N  -Dexec.executable='echo'  -Dexec.args='${project.version}'  org.codehaus.mojo:exec-maven-plugin:1.3.1:exec 
        #SRC_VERSION=`mvn --file ${SRC_TOP} -q -N -Dexec.executable='echo'  -Dexec.args='${project.version}'  org.codehaus.mojo:exec-maven-plugin:1.3.1:exec | tail -n 1`
    elif [[ -n $(eval ${DETECT_NODEJS}) ]];then
#        package=`echo $(eval ${DETECT_NODEJS}) | head -n 1`
#        SRC_TOP=$(realpath $(dirname ${package}))
        SRC_TYPE=nodejs
        echo "SRC_TYPE=${SRC_TYPE}"
        #SRC_VERSION=$(cd ${SRC_TOP};npm run packageVersion |tail -n 1)
    elif [[ -n $(eval ${DETECT_DEFAULT_GIT}) ]];then
#        topfile=`echo $(eval ${DETECT_DEFAULT_GIT}) | head -n 1 | awk '{print $1}'`
#        SRC_TOP=`echo $(realpath $(dirname ${topfile})) | head -n 1`
        SRC_TYPE=none
        echo "SRC_TYPE=${SRC_TYPE}"
        #SRC_VERSION="$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
    else
        SRC_TYPE=none
        echo "SRC_TYPE=${SRC_TYPE}"
        SRC_VERSION="v1"
        echo "Warn can't detect SRC_VERSION !!!!"
    fi
    echo "SRC_TYPE=${SRC_TYPE}"
    echo CI_PROJECT_REPOSITORY_LANGUAGES=${CI_PROJECT_REPOSITORY_LANGUAGES}
    if [[ -n $(eval ${DETECT_DEFAULT_GIT}) ]];then
        PWD_HAVE_DOT_GIT=1
    else 
        PWD_HAVE_DOT_GIT=0
    fi
    ###################################################################  
}

function do_src_get_reponame()
{
    echo "$FUNCNAME"
    if [[ -z ${SRC_TOP} ]];then
        echo "can't detect SRC_TOP"
        exit 1
    fi
    if [[ -n ${TEAMCITY_GIT_PATH} ]];then
        echo "Teamcity CICD"
        SRC_BRANCHER_NAME=$(git branch | grep \* | cut -d ' ' -f2)
        SRC_REPO_NAME=${TEAMCITY_BUILDCONF_NAME}
        BUILD_COUNTER="t${BUILD_NUMBER}"
    elif [[ -n ${JENKINS_URL} ]];then
        echo "Jenkins CICD"
        SRC_BRANCHER_NAME=$(git branch | grep \* | cut -d ' ' -f2)
        SRC_REPO_NAME="${JOB_NAME}"
        BUILD_COUNTER="j${BUILD_NUMBER}"
    elif [[ -n ${GITLAB_CI} ]];then
        echo "GITLAB CICD"
        SRC_BRANCHER_NAME=${CI_COMMIT_REF_SLUG}
        SRC_REPO_NAME="${CI_PROJECT_NAME}"
        BUILD_COUNTER="g${CI_PIPELINE_ID}"
    else
        echo "manual CICD"
        SRC_BRANCHER_NAME=$(git branch | grep \* | cut -d ' ' -f2)   
        SRC_REPO_NAME=$(basename $(realpath ${CI_PROJECT_PATH}))
        BUILD_COUNTER="c1"
    fi
    if [[ -f ${SRC_TOP}/VERSION ]]; then
        SRC_VERSION=$(head -n 1 ${SRC_TOP}/VERSION | awk '{print $1}')
    else
        SRC_VERSION=1.0.0
    fi
    if [[ -n ${CI_COMMIT_SHORT_SHA} ]];then
      SRC_GIT_COMMIT_ID=${CI_COMMIT_SHORT_SHA}
    else
      SRC_GIT_COMMIT_ID="$(cd ${SRC_TOP};git rev-parse --short HEAD )"
    fi
    echo "SRC_TOP=${SRC_TOP}"
    echo "SRC_BRANCHER_NAME=${SRC_BRANCHER_NAME}"
    echo "SRC_VERSION=${SRC_VERSION}"
    echo "SRC_REPO_NAME=${SRC_REPO_NAME}"
    echo "SRC_GIT_COMMIT_ID=${SRC_GIT_COMMIT_ID}"
    echo "BUILD_COUNTER=${BUILD_COUNTER}"
}

function do_src_analysis_nodejs()
{
    echo "$FUNCNAME"
    echo "TODO"
}

function do_src_analysis_java()
{
   echo "$FUNCNAME"
}
function do_src_analysis()
{
    echo "$FUNCNAME"
    echo "ENABLE_SONAR=${ENABLE_SONAR}"
    do_src_get_srctype_by_topdir
    
    case ${SRC_TYPE} in
        nodejs)
            echo "nodejs,"
            do_src_analysis_nodejs
            ;;
        java)
            echo "java,"
            do_src_analysis_java
            ;;
        python)
            echo "python, not support yet"
            ;;
        go)
            echo "go, not support yet"
            ;;
        c)
            echo "c/c++, not support yet"
            ;;
        *)
            echo "not support yet"
            ;;
    esac
}

function do_artifact_build_nodejs()
{
    echo "$FUNCNAME"
}
function do_artifact_build_java()
{
    echo "$FUNCNAME"
    if [[ ${ENABLE_SONAR} -ne 0 ]];then
        if [[ ${PWD_HAVE_DOT_GIT} -eq 1 ]];then
            SONAR_KEY="$(echo ${CI_PROJECT_PATH}| tr / .)"
        else
            SONAR_KEY="$(echo ${CI_PROJECT_PATH}-$(basename $PWD)| tr / .)"
        fi
        SONAR_OPT="sonar:sonar -Dsonar.projectKey=${SONAR_KEY} -Dsonar.projectName=${SONAR_KEY}"
    else
        SONAR_OPT=""
    fi
    if [[ ${ARTIFACT_DEPLOY} -gt 0 ]];then
        mvn clean package deploy ${SONAR_OPT} ${S2I_MVN_OPT}
        exit 0
    else
        mvn clean package ${SONAR_OPT} ${S2I_MVN_OPT}
    fi
}
function do_artifact_build()
{
    echo "$FUNCNAME"
    if [[ ${ARTIFACT_DEPLOY} -gt 0 ]];then
        ARTIFACT_DEPLOY=1
    else
        ARTIFACT_DEPLOY=0
    fi
    echo "NEXUS_REPO=${NEXUS_REPO}"
    echo "NEXUS_RELEASE=${NEXUS_RELEASE}"
    echo "ARTIFACT_DEPLOY=${ARTIFACT_DEPLOY}"

    do_src_get_srctype_by_topdir
    case ${SRC_TYPE} in
        nodejs)
            do_artifact_build_nodejs
            ;;
        java)
            do_artifact_build_java
            ;;
        python)
            echo "not support yet"
            ;;
        go)
            echo "not support yet"
            ;;
        *)
            echo "not support source, or detect fail, commit your build script to ${CI_PROJECT_PATH}/build.sh"
            ;;
    esac
}

function do_docker_get_imgurl_by_dockerfile()
{
    echo "$FUNCNAME"
    if [[ ! -f .dockerignore ]];then
      echo ".git" > .dockerignore
    fi
    DOCKER_THIS_DOCKERFILE=$(realpath $1)
    if [[ $# -gt 1 ]];then
        MY_SLOT=$2
     else
        MY_SLOT=0
    fi
    
    echo "DOCKER_THIS_DOCKERFILE=${DOCKER_THIS_DOCKERFILE}"
    if [[ -z ${DOCKER_THIS_DOCKERFILE} ]];then
        echo "can't detect Dockerfile"
        exit 1
    fi
    DOCKFILE_DIR=$(dirname ${DOCKER_THIS_DOCKERFILE})

#    DOCKER_THIS_NS=$(perl -e "@DOCKERNS = split(/\s+/, \$ENV{DOCKER_NS});\$NS=\$DOCKERNS[$MY_SLOT];\$NS =~ s/[\p{Pi}\p{Pf}'\"]//g;print STDOUT \$NS")
#    DOCKER_THIS_NS=${DEFAULT_NS}
    K8S_THIS_NS=$(perl -e "@K8SNS = split(/\s+/, \$ENV{K8S_NS});print STDOUT \$K8SNS[$MY_SLOT];")

    if [[ "" == "${DOCKER_REPO}" ]];then
        DOCKER_REPO=${DOCKER_REPO:-harbor.benload.com}
    fi
    if [[ "" == "${DOCKER_NS}" ]];then
    DOCKER_NS=${DEFAULT_NS}
    fi
    if [[ "" == "${DOCKER_NS}" ]];then
    DOCKER_NS="default"
    fi
    if [[ "" == "${DOCKER_THIS_NS}" ]];then
    DOCKER_THIS_NS=${DOCKER_NS}
    fi
    do_src_get_reponame
    
    DOCKER_SUBDIR_NAME=$(basename $(realpath  ${DOCKFILE_DIR}))
    if [[ "${DOCKFILE_DIR}" == "${CI_PROJECT_PATH}" ]];then
        DOCKER_IMG_TAG=${SRC_BRANCHER_NAME}-${SRC_GIT_COMMIT_ID}-${SRC_VERSION}-${BUILD_COUNTER}
    else
        DOCKER_IMG_TAG=${SRC_BRANCHER_NAME}-${SRC_GIT_COMMIT_ID}-${SRC_VERSION}-${BUILD_COUNTER}-${DOCKER_SUBDIR_NAME}
    fi
    DOCKER_URL=${DOCKER_REPO}/${DOCKER_THIS_NS}/${SRC_REPO_NAME}:${DOCKER_IMG_TAG}
    DOCKER_SVC_PORTS=$(egrep EXPOSE -i ${DOCKER_THIS_DOCKERFILE}|egrep -v '#' |awk '{print $2}'| awk '{for(i=1;i<=NF;i++){printf "%s,", $i}}' |   perl -ne 's/(.+)\,$/\1/g;print' )
    
    if [[ -z ${DOCKER_SVC_PORTS} ]];then
        echo "NO EXPOSE in ${DOCKFILE}"
        DOCKER_SVC_PORTS=""
    fi
    echo "DOCKER_SVC_PORTS=${DOCKER_SVC_PORTS}"
    echo "DOCKER_THIS_DOCKERFILE=${DOCKER_THIS_DOCKERFILE}"
    echo "DOCKFILE_DIR=${DOCKFILE_DIR}"
    echo "DOCKER_REPO=${DOCKER_REPO}"
    echo "DOCKER_NS=${DOCKER_NS}"
    echo "DOCKER_THIS_NS=${DOCKER_THIS_NS}"
    echo "DOCKER_SUBDIR_NAME=${DOCKER_SUBDIR_NAME}"
    echo "DOCKER_IMG_TAG=${DOCKER_IMG_TAG}"
    echo "DOCKER_URL=${DOCKER_URL}"
    echo "K8S_THIS_NS=${K8S_THIS_NS}"
}



function do_docker_build()
{
    echo "$FUNCNAME"
    if [[ -z ${DOCKER_BUILD} ]];then
        DOCKER_BUILD=1
    fi
    if [[ ${DOCKER_BUILD} -eq 0 ]];then
        echo "DOCKER_BUILD=${DOCKER_BUILD}, exit 0"
        exit 0
    else
        echo "start docker build"
    fi
    
    echo "detect Dockerfile"
    DETECT_DOCKERFILE="find ${SRC_TOP}   -maxdepth 1 -iname Dockerfile | sort"
    eval ${DETECT_DOCKERFILE}
    eval ${DETECT_DOCKERFILE} | while read d;do
        if [[ -n $(eval ${DETECT_DOCKERFILE}) ]];then
            #DOCKFILE=$(realpath `echo $(eval ${DETECT_DOCKERFILE})| head -n 1`)
            DOCKFILE=$(realpath `echo ${d} | head -n 1`)
            DOCKFILE_DIR=$(dirname ${DOCKFILE})
        else
            echo "can't detect Dockerfile"
            exit 0
        fi

        
        DOCKER_SVC_PORTS=$(egrep EXPOSE -i ${DOCKFILE}|egrep -v '#' |awk '{print $2}'| awk '{for(i=1;i<=NF;i++){printf "%s,", $i}}' |   perl -ne 's/(.+)\,$/\1/g;print' )
        
        if [[ -z ${DOCKER_SVC_PORTS} ]];then
            echo "warn, no EXPOSE in ${DOCKFILE}"
            DOCKER_SVC_PORTS=80
        fi
        
        do_docker_get_imgurl_by_dockerfile ${d} 0
        echo "########################################## ${ACTION_STAGE}"
        echo "build docker image"
        echo "DOCKFILE=${DOCKFILE}"
        echo "DOCKFILE_DIR=${DOCKFILE_DIR}"
        echo "DOCKER_BUILD=${DOCKER_BUILD}"
        echo "DOCKER_REPO=${DOCKER_REPO}"
        echo "DOCKER_NS=${DOCKER_NS}"
        echo "DOCKER_IMG_TAG=${DOCKER_IMG_TAG}"
        echo "DOCKER_URL=${DOCKER_URL}"
        echo "DOCKER_SVC_PORTS=${DOCKER_SVC_PORTS}"
        echo "##########################################"
        docker build ${S2I_DOCKER_OPT} --pull -f ${DOCKFILE} -t ${SRC_REPO_NAME}:x${BUILD_COUNTER} ${DOCKFILE_DIR}
        docker tag ${SRC_REPO_NAME}:x${BUILD_COUNTER} ${DOCKER_URL}

        slot=0
        echo ${DOCKER_NS}
        echo ${DOCKER_NS} | perl -ne '@ns=split /\s+/, $_;foreach(@ns){print "$_\n"} '  |
        while read ns;do
            if [[ ${slot} -gt 0 ]];then
                do_docker_get_imgurl_by_dockerfile ${d} ${slot}
            fi
            echo "DOCKER_URL=${DOCKER_URL}"
            docker tag ${SRC_REPO_NAME}:x${BUILD_COUNTER} ${DOCKER_REPO}/${DOCKER_THIS_NS}/${SRC_REPO_NAME}:latest
            docker tag ${SRC_REPO_NAME}:x${BUILD_COUNTER} ${DOCKER_URL}
            docker push ${DOCKER_URL}
            docker push ${DOCKER_REPO}/${DOCKER_THIS_NS}/${SRC_REPO_NAME}:latest
            set +e
            docker rmi ${DOCKER_URL}
            docker rmi ${DOCKER_REPO}/${DOCKER_THIS_NS}/${SRC_REPO_NAME}:latest
            set -e
            slot=$((${slot} + 1))

            #report
            echo ${DOCKER_URL} > ${S2I_REPORT_DIR}/s2i.${CI_JOB_STAGE}.${SRC_REPO_NAME}.${DOCKER_SUBDIR_NAME}.${DOCKER_SVC_PORTS}.img.txt
        done
        
        set +e
        docker rmi ${SRC_REPO_NAME}:x${BUILD_COUNTER}
        set -e
        echo -e "\n\n"
    done
}

function do_deploy_k8s()
{
    echo "$FUNCNAME"
    TRYTOP=$(xdir=${SCRIPT_DIR};cd ${SCRIPT_DIR}; while /usr/bin/test ! -e .TOP ; do \
            xdir=`cd ../;pwd`;                       \
            if [ "$xdir" = "/" ] ; then              \
               echo  1>&2; \
               break;                               \
            fi ;                                    \
            cd $xdir;                               \
            done ;                                  \
            pwd;)
    WORKDIR=$(pwd)
    if [[ -z ${TRYTOP} ]];then
        TRYTOP=${WORKDIR}
    fi
    if [[ -z ${K8S_AUTOCD} ]];then
        K8S_AUTOCD=1
    fi
    if [[ -z ${K8S_NS} ]];then
        K8S_NS=${DEFAULT_NS}${K8S_NS_SUFFIX}
    fi
    if [[ -z ${K8S_NS} ]];then
        K8S_NS=default${K8S_NS_SUFFIX}
    fi
    if [[ -z ${K8S_DOMAIN_INTERNAL} ]];then
        K8S_DOMAIN_INTERNAL="bu5-idc.k8s.cd"
    fi
    if [[ -z ${K8S_DOMAIN_PUBLIC} ]];then
        K8S_DOMAIN_PUBLIC="bu5-idc.benload.com"
    fi
    

    
    if [[ -z ${K8S_SVCNAMES} ]];then
        K8S_SVCNAMES=${SRC_REPO_NAME}
    fi
    if [[ -n ${K8S_KUBECONFIG} ]];then
        echo "custom kubeconfig"
        export KUBECONFIG=${K8S_KUBECONFIG}
    else
        K8S_KUBECONFIG="${HOME}/.kube/config"
        echo "default kubeconfig"
    fi
    echo "K8S_AUTOCD=${K8S_AUTOCD}"
    echo "K8S_NS=${K8S_NS}"
    echo "K8S_SVCNAMES=${K8S_SVCNAMES}"
    echo "DEPLOY_SUFFIX=${DEPLOY_SUFFIX}"
    echo "K8S_KUBECONFIG=${K8S_KUBECONFIG}"
    echo "K8S_DOMAIN_INTERNAL=${K8S_DOMAIN_INTERNAL}"
    echo "K8S_DOMAIN_PUBLIC=${K8S_DOMAIN_PUBLIC}"
    echo "##########################################"
    echo "detect Dockerfile"
    DETECT_DOCKERFILE="find ${SRC_TOP}   -maxdepth 1 -iname Dockerfile | sort"
    eval ${DETECT_DOCKERFILE}
    DOCKERFILE_COUNT=`eval ${DETECT_DOCKERFILE}|wc -l`
    if [[ ${DOCKERFILE_COUNT} -eq 0 ]];then
        echo "no Dockerfile detect"
        exit 0
    fi
    kubectl get node
    kubectl  cluster-info
    ### ensure ns exists
    set +e
    kubectl --kubeconfig ${K8S_KUBECONFIG} get ns ${K8S_NS}
    rv=$?
    set -e
    if [[ ${rv} -ne 0 ]];then
        kubectl --kubeconfig ${K8S_KUBECONFIG} create  namespace ${K8S_NS}
    fi
    i=0
    eval ${DETECT_DOCKERFILE} | while read d;do
        i=$(( $i + 1 ))
        if [[ -n $(eval ${DETECT_DOCKERFILE}) ]];then
            #DOCKFILE=$(realpath `echo $(eval ${DETECT_DOCKERFILE})| head -n 1`)
            DOCKFILE=$(realpath `echo ${d} | head -n 1`)
            DOCKFILE_DIR=$(dirname ${DOCKFILE})
        else
            echo "can't detect Dockerfile"
            exit 0
        fi
        if [[ ${DOCKERFILE_COUNT} -gt 0 ]];then
            K8S_SVCNAMES=$(basename $(dirname ${DOCKFILE}))
        fi
        
        if [ ${K8S_AUTOCD} -gt 0 ];then
          slot=0
          for MY_K8S_NS in ${K8S_NS};do
            echo "$i##########################################${DOCKFILE}"
            do_docker_get_imgurl_by_dockerfile ${d} $slot
            for SVCNAME in ${K8S_SVCNAMES};do
                bash ${SCRIPT_DIR}/k8s-app-import ${DOCKER_URL} ${SVCNAME} ${MY_K8S_NS} "${DOCKER_SVC_PORTS}" ${K8S_AUTOCD} ${K8S_DOMAIN_INTERNAL} ${K8S_DOMAIN_PUBLIC}
                #report
            done
            slot=$(( $slot + 1 ))
          done
        fi
    done
}

function s2i_metric()
{
  set +e
  which metric-util-lib >/dev/null 2>&1
  rv=$?
  if [[ ${rv} -eq 0 ]];then
    set -o allexport; source metric-util-lib >/dev/null;set +o allexport
  fi

  set -e
}

trap "s2i_metric" INT QUIT TERM EXIT

if [[ -z ${S2E_CALLED_TIME} ]];then
  S2E_CALLED_TIME=$(stat -c%X /proc/"$$")
fi
export S2E_CALLED_TIME
export SRC_TOP
# main logic
###################################################################


# check config valid, not valid will regenerate
set +e
gitlab current-user get > /dev/null 2>&1
RV=$?
set -e

if [[ ${RV} -ne 0 ]];then
  if [[ -d /root ]];then
# gitlab cli config file not exist
cat > /root/.python-gitlab.cfg <<EOF
[global]
default = default
ssl_verify = true
timeout = 5

[default]
url = ${CI_SERVER_URL}
private_token = ${CI_PRIVATE_TOKEN}
api_version = 4
EOF
perl -ni -e "s#url.+#url = ${CI_SERVER_URL}#g;print" /root/.python-gitlab.cfg
perl -ni -e "s#private_token.+#private_token = ${CI_PRIVATE_TOKEN}#g;print" /root/.python-gitlab.cfg
  fi
fi


case ${ACTION_STAGE} in
    anal*)
        do_src_analysis
        ;;
    art*)
        do_artifact_build
        ;;
    docker)
        do_docker_build
        ;;
    deploy)
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_deploy_k8s
        ;;
    deploy-update-default)
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_deploy_k8s
        ;;
    deploy-update-blue)
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=0
        export DEPLOYMENT_BLUE=1
        do_deploy_k8s
        ;;
    deploy-insert-default)
        export DEPLOYMENT_UPDATE_IMG=0
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_deploy_k8s
        ;;
    ACTION_ALL*)
        echo "自动检测源码类型，并做artifact 构建，docker 构建"
        do_artifact_build
        do_docker_build
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_deploy_k8s
        ;;
    help*)
        echo "${USAGE}"
        ;;
    exec)
        shift 2
        set +e
        which $1 >/dev/null 2>&1
        rv=$?
        set -e
        if [[ $rv -ne 0 ]];then
          echo "Error, $1 cmd not exist in PATH"
          exit 1
        else
          echo "OK, try exec $@ , CMD = $@ $(which $1)"
          exec $@
        fi
        ;;
    *)
        echo "unkown action"
        ;;
esac