#!/bin/bash
#cicd toolset
#author: jimin.huang
#email: jimin.huang@benload.com
#email: jimminh@163.com
set -e
set +x

###################################################################
THIS_SCRIPT=$(realpath $(cd "$(dirname "${BASH_SOURCE:-$0}")"; pwd)/$(basename ${BASH_SOURCE:-$0}))
#automatic detection TOPDIR
SCRIPT_DIR=$(dirname $(realpath ${THIS_SCRIPT}))

USAGE="
  usage:
  A cicd tool, from src to artifact, to docker img, deploy into kubernetes:
  I. default do all action(artifact,docker,deploy):
  $(basename $(realpath $0)) /path/to/srctop

  II. only do specify action:
  $(basename $(realpath $0)) /path/to/srctop [ analysis|artifact|docker|deploy|deploy-update-blue ]

    1. only do artifact
    $(basename $(realpath $0)) /path/to/srctop artifact

    2. only do docker build push
    export DOCKER_REPO=harbor.benload.com
    export DOCKER_NS=bu5
    $(basename $(realpath $0)) /path/to/srctop docker

    3. only do kubernetes deploy
    export K8S_KUBECONFIG=/root/.kube/config
    export K8S_NS_SUFFIX=-dev
    export K8S_NS=default
    export K8S_DOMAIN_INTERNAL=benload.cn
    export K8S_DOMAIN_PUBLIC=bu5-dev.tx
    export INGRESS_INTERNAL_ENABLE=1
    export INGRESS_PUBLIC_ENABLED=1
    export INGRESS_CLASS_INTERNAL=nginx
    export INGRESS_CLASS_PUBLIC=nginx
    $(basename $(realpath $0)) /path/to/srctop deploy

  III. do exec cmd:
  $(basename $(realpath $0)) /path/to/rundir exec wrappercmd [...]
    1. do ls on /root directory
    $(basename $(realpath $0)) /root ls
"

if [[ $# -lt 1 ]];then
    echo "${USAGE}"
    exit 1
else
    SRC_TOP=$(realpath $1)
fi

if [[ $# -gt 1 ]];then
    ACTION_STAGE=$2
else
    ACTION_STAGE="ACTION_ALL"
fi
if [[ -z ${CI_PROJECT_PATH} ]];then
  CI_PROJECT_PATH="$(git rev-parse --show-toplevel)"
fi
if [[ -z ${CI_PROJECT_PATH} ]];then
CUR_DIR=$(pwd)
CI_PROJECT_PATH=$(xdir=${CUR_DIR};cd ${CUR_DIR}; while /usr/bin/test ! -d .git ; do \
        xdir=`cd ../;pwd`;                       \
        if [ "$xdir" = "/" ] ; then             \
           echo  1>&2;                          \
           cd ${CUR_DIR}                        \
           break;                               \
        fi ;                                    \
        cd $xdir;                               \
        pwd;                                    \
        done)
fi
DEFAULT_NS="${S2E_ORG}${S2E_NS}"
if [[ "" == ${DEFAULT_NS} ]];then
    DEFAULT_NS="$(echo ${CI_PROJECT_PATH} | perl -ne 's@^\/@@;print' | awk -F"/" '{print $1$2}')"
fi
if [[ "" == ${DEFAULT_NS} ]];then
    DEFAULT_NS="default"
fi
echo "SRC_TOP=${SRC_TOP}"
echo "CI_PROJECT_PATH=${CI_PROJECT_PATH}"
echo "DEFAULT_NS=${DEFAULT_NS}"
S2I_REPORT_DIR=$(git rev-parse --show-toplevel)/.s2i
mkdir -p ${S2I_REPORT_DIR}
RUNNER_HOME=$(eval echo ~$USER)

cd ${SRC_TOP}

# try to guest java or nodejs, ...
echo "try to detect java/nodejs source"
DETECT_JAVA="find ${SRC_TOP} -maxdepth 1 -iname pom.xml"
DETECT_NODEJS="find ${SRC_TOP} -maxdepth 1 -iname package.json"
DETECT_DEFAULT_TOP="find ${SRC_TOP}   -maxdepth 1 -iname .TOP"
DETECT_DEFAULT_GIT="find ${SRC_TOP}   -maxdepth 1 -iname .git"
eval ${DETECT_JAVA}
eval ${DETECT_NODEJS}
if [[ -n $(eval ${DETECT_JAVA}) ]];then
    pom=`echo $(eval ${DETECT_JAVA}) | head -n 1`
    SRC_TYPE=java
    echo "SRC_TYPE=${SRC_TYPE}"
elif [[ -n $(eval ${DETECT_NODEJS}) ]];then
    SRC_TYPE=nodejs
    echo "SRC_TYPE=${SRC_TYPE}"
elif [[ -n $(eval ${DETECT_DEFAULT_GIT}) ]];then
    SRC_TYPE=none
    echo "SRC_TYPE=${SRC_TYPE}"
else
    SRC_TYPE=none
    echo "SRC_TYPE=${SRC_TYPE}"
fi
echo "检测为 SRC_TYPE=${SRC_TYPE}"
echo CI_PROJECT_REPOSITORY_LANGUAGES=${CI_PROJECT_REPOSITORY_LANGUAGES}
if [[ -n $(eval ${DETECT_DEFAULT_GIT}) ]];then
    PWD_HAVE_DOT_GIT=1
else
    PWD_HAVE_DOT_GIT=0
fi
###################################################################
echo "# SRC_TYPE=${SRC_TYPE}"


if [[ -n ${JENKINS_URL} ]];then
    echo "Jenkins CICD"
    SRC_REPO_NAME=$(git config remote.origin.url | perl -n -e 'm/.+\/([-_\w]+).git/g;print $1'| tr '_' '-')
    BUILD_COUNTER="j${BUILD_NUMBER}"
elif [[ -n ${GITLAB_CI} ]];then
    echo "GITLAB CICD"
    SRC_REPO_NAME="${CI_PROJECT_NAME}"
    BUILD_COUNTER="g${CI_PIPELINE_ID}"
elif [[ -n ${GITHUB_ACTIONS} ]];then
    echo "GITHUB CICD"
    SRC_REPO_NAME=$(basename $(realpath ${CI_PROJECT_PATH}))
    BUILD_COUNTER="$(date +%Y%m%d)"
else
    echo "manual CICD"
    SRC_REPO_NAME=$(basename $(realpath ${CI_PROJECT_PATH}))
    BUILD_COUNTER="c1"
fi
SRC_REPO_NAME=$(echo ${SRC_REPO_NAME} | tr '_' '-')
SRC_GIT_COMMIT_ID="$(cd ${SRC_TOP};git rev-parse --short HEAD )"

#### 分支检查
echo -e "\n\n\n\n"
if [[ -n ${JONE_RUN_ENV} ]];then
    if [[  "${JONE_RUN_ENV}" =~ "test" ]] || [[ "${JONE_RUN_ENV}" =~ "uat" ]];then

        # 确保 RC_NAME 已创建
        set +e
        git fetch origin feature-testing >/dev/null 2>&1
        rv=$?
        set -e
        if [[ ${rv} -ne 0 ]];then
            set +e
            git pull origin/master >/dev/null 2>&1
            git checkout -f origin/master >/dev/null 2>&1
            git checkout -B feature-testing >/dev/null 2>&1
            git push --set-upstream origin feature-testing && echo "你好，已帮你创建好feature-testing 分支"
            set -e
        else
            echo echo "你好，feature-testing 已存在"
        fi
        
        # 如果不是只勾选 feature-testing，报错，并提示 
        if [[ ${JONE_BRANCH_FEATRUE} =~ .+ ]] && [[ ! ${JONE_BRANCH_FEATRUE} =~ feature-testing$ ]];then
            echo "你好，部署 test、uat请按照以下步骤:"
            echo "1. 登陆工蜂或gitlab，创建MergeRequest，源分支你的转测分支, 目的分支feature-testing, 审核人为小组负责人"
            echo "2. 通知小组负责人，进行Review并合入进feature-testing"
            echo "3. 登陆Jenkins，分支只勾选 feature-testing , 环境勾选test、或者uat"
            echo "4. 单击构建完成部署"
            echo "5. Tapd/Jira 更新状态，通知QA进行测试"
            TIPS_EXIT=1
        fi
    fi
    if [[  "${JONE_RUN_ENV}" =~ "prd" ]] && [[ -n ${JONE_BRANCH_FEATRUE} ]];then
        echo "你好，发布流程不符合流程"
        echo "部署生产只部署master分支，不允许勾选任何分支"
        echo "请不勾选后，重试"
        echo -e "\n"
        echo "部署 prd，发布新特性步骤如下："
        echo "1. 登陆Jenkins,不勾选分支，环境选 prd，单击构建完成部署"
        echo "2. 登陆Tapd状态, 填写发布评审单，通知运维准备进行发布，通知QA准备进行生产验收 "
        echo "3. 运维发布完成"
        echo "4. QA验收完成"
        echo "5. 运维关闭发布评审单"
        echo -e "\n"
        echo "前期自测、提测工作步骤:"
        echo "0. 开发人员合入feature-testing 分支的特性，并在test、uat环境经过验证"
        echo "0. 开发人员,工蜂或gitlab创建MergeRequest，源分支feature-testing, 目的分支master, 审核人为小组负责人"
        echo "1. 小组负责人跟QA确认，feature-testing 已经在test环境经过质量测试，在uat环境经过用户测试"
        echo "2. 小组负责人MergeRequest 通过，删除feature-testing 分支"

        echo -e "\n"
        echo "部署 prd，解决生产缺陷步骤如下："
        echo "1. 开发人员 登陆工蜂或Gitlab，创建MergeRequest，源分支hotfix-xxx, 目的分支master, 审核人为小组负责人"
        echo "2. 小组负责人 MergeRequest 通过，删除hotfix-xxx分支"
        echo "3. 小组负责人 登陆Jenkins,不勾选分支，环境选 prd，单击构建完成部署，通知运维发布"
        echo "4. 运维发布完成，通知QA，验收"
        echo "5. QA生产环境验收完成，QA关闭tapd/jira缺陷单"

        echo -e "\n"
        echo -e "\n"
        echo -e "前期生产bug验证工作："
        echo "0. 开发人员从master拉取hotfix-xxx 分支，并修改代码提交"
        echo "0. 开发人员在只勾选hotfix-xxx，并部署到dev环境"
        echo "0. 开发人员协调QA、产品等人在dev环境，验证缺陷解决"
        TIPS_EXIT=1
    fi
    set -e
    if [[ ${TIPS_EXIT} -ne 0 ]];then
        echo -e "\n\n\n\n\n"
        echo "分支模型tips#############################################################################"
        echo "tips: 部署dev环境，      建议 只勾选feature-testing和你自己的feature-xxx特性分支"
        echo "tips: 部署test、uat环境，强制 要求只能勾选feature-testing分支进行部署，或者一个分支都不勾"
        echo "tips: 部署prd环境，      强制 要求只能一个分支都不勾"
        echo -e "\n\n"
        echo "Jenkins CI 的构建部署过程"
        echo  "勾部署dev，      从最新master分支拉取临时分支，合入feature-testing和其他勾选featrue分支后，构建出docker镜像，部署到 dev"
        echo  "勾部署test或uat，从最新master分支拉取临时分支，合入feature-testing后，构建出docker镜像，部署到test或uat"
        echo  "勾部署prd，      从最新master分支，构建出出docker镜像，部署到 dev"
        echo -e "\n\n"
        echo "环境与分支对应关系如下："
        echo "master 分支        ---------------------  对应 prd环境"
        echo "feature-testing 分支 ---------------------  对应 test、uat环境"
        echo "feature-testing和其他勾选featrue 分支 ----  对应 dev环境"
#        exit 1
    fi
fi


 # 基线分支设置为master
JONE_BRANCH_BASE=origin/master
if [[ "${SRC_REPO_NAME}" =~ "scrm-common-sdk" ]];then
  echo "scrm-common-sdk 比价特别，不使用任何基线"
  JONE_BRANCH_BASE=${JONE_BRANCH_FEATRUE}
fi
BR_BASELINE=${JONE_BRANCH_BASE}
## jone, aone 模式
if [[ -z ${JONE_BRANCH_FEATRUE} ]];then
# 特性分支为空时，集成部署分支名设置为master
  CI_DST_BRANCHER_NAME=master-$(date +%Y%m%d)
  UNSTABLE=''
elif [[ ${JONE_BRANCH_FEATRUE} =~ .*master ]] || [[ ${JONE_BRANCH_FEATRUE} =~ .*release* ]];then
 # 特性分支不为空，且包含master或release报错
 echo "特性分支不允许包含master，因为jone分支模型做分支集成时，基线分支就是master。"
 echo "过程是从master最新拉取一个集成分支，然后依次把特性分支merge，再构建, 再部署"
 exit -1
elif [[ -n ${JONE_BRANCH_FEATRUE} ]] ;then
 # 特性分支不为空, 且不包含master 或者release
    UNSTABLE='unstable-'
    BRS_FEATURE=($(echo ${JONE_BRANCH_FEATRUE} | perl -n  -e 'my $br=$_;my @brs= split /\,/, $br; foreach(@brs) { print  " $_\n"}' | egrep -v "master|release"))
    BRS_FEATURE_NUM=${#BRS_FEATURE[*]}

    if [[ ${BRS_FEATURE_NUM} -lt 1 ]];then
        echo "BRS_FEATURE_NUM=${BRS_FEATURE_NUM}"
        echo "JONE_BRANCH_FEATRUE=${JONE_BRANCH_FEATRUE}"
        echo "Warn, JONE_BRANCH_FEATRUE 特性分支为空，（分支名中不含master，不含release）"
    fi
    if [[ "${JONE_BRANCH_BASE}" == "" ]];then
        echo "JONE_BRANCH_BASE 请选择一个基线分支，（分支名中含master或者含release）"
        echo "JONE_BRANCH_BASE=${JONE_BRANCH_BASE}"
        echo "JONE_BRANCH_BASE 为空, 使用默认基线 master "
        BR_BASELINE=origin/master
    else
       # 基线分支, 只能master 和各release分支的一个分支
       # BR_BASELINE=$(echo ${JONE_BRANCH_BASE} | perl -n  -e 'my $br=$_;my @brs= split /\,/, $br; foreach(@brs) { print  " $_\n"}' | egrep "master|release"| head -n 1)
       echo "${BR_BASELINE}"
    fi
    if [[ -f ${SRC_TOP}/VERSION ]]; then
        SRC_VERSION=$(head -n 1 ${SRC_TOP}/VERSION | perl -ne '$_ =~ /((0|[1-9][0-9]*).(0|[1-9][0-9]*).?(0|[1-9][0-9]*)*)/;print $1')
    else
        SRC_VERSION=$(date +%Y%m%d)
    fi
    
   # 特性分支不为空时，集成部署分支设置为选取的环境 
   # 需要push回git server的集成分支名，不引入动态变化变量，保障多个特性分支名的集成分支唯一
   # CI_DST_BRANCHER_NAME="i-$(echo ${JONE_RUN_ENV}| tr -d '_-')-$(echo ${JONE_BRANCH_FEATRUE}| tr ',' '_' |perl -ne 's|origin/||g;print')"
    CI_DST_BRANCHER_NAME="$(echo ${JONE_RUN_ENV}| tr -d '_-')-jone"
    if [[ ${JONE_RUN_ENV} =~ "dev" ]] || [[ ${JONE_RUN_ENV} =~ "test" ]];then
    # 目的地为dev，或者 test时，增加动态变量，防止分支已存在
        CI_DST_BRANCHER_NAME=${CI_DST_BRANCHER_NAME}
    fi
    SRC_GIT_COMMIT_ID="$(cd ${SRC_TOP};git rev-parse --short HEAD )"
    BUILD_COUNTER=${BUILD_COUNTER}
fi

if [[ ${BRS_FEATURE_NUM} -eq 0 ]];then
    TAG_BR_BASE="$(echo ${JONE_BRANCH_BASE} | perl -ne 's|origin/||g;print')-$(git rev-parse --short ${JONE_BRANCH_BASE})"
    TAG_BR_FEATURES="-$(date +%Y%m%d)-${BUILD_COUNTER}"
elif [[ ${BRS_FEATURE_NUM} -eq 1 ]];then
    TAG_BR_BASE=""
    TAG_BR_FEATURES="$(echo ${BRS_FEATURE[*]}| perl -ne 's|origin/||g;print' | tr -d  '[:space:]')-$(git rev-parse --short ${BRS_FEATURE[*]})-$(date +%Y%m%d)"
elif [[ ${BRS_FEATURE_NUM} -gt 1 ]];then
    for br in ${BRS_FEATURE[*]};do
        if ! [[ "$(echo ${br} |perl -ne 's|origin/||g;print')" =~ (feature|hotfix) ]];then
           echo "\n\n"
           echo "你好，分支名 ${br} 不符合分支命名规范:"
           echo "新功能、新特性分支的分支名必须feature开头，比如  feature-xxx 或者 feature-xx-STROYID等"
           echo "解决生产环境bug拉取的分支必须hotfix开头，比如  hotfix-xxx 或者 feature-xx-JIRAID等"
           echo "\n\n"
           echo "feature 分支或者hotfix分支合入master后请及时删除"
#           exit 1
        fi
    done
    TAG_BR_BASE="${JONE_RUN_ENV}"
    TAG_BR_FEATURES="-f${BRS_FEATURE_NUM}-$(date +%Y%m%d)"
fi
       
echo "# SRC_TOP=${SRC_TOP}"

echo "JONE_BRANCH_BASE=${JONE_BRANCH_BASE}"
echo "JONE_BRANCH_FEATRUE=${JONE_BRANCH_FEATRUE}"

echo "# BR_BASELINE=${BR_BASELINE}"
echo '# ${BRS_FEATURE[*]}'"=${BRS_FEATURE[*]}"
echo "# BRS_FEATURE_NUM=${BRS_FEATURE_NUM}"
echo "# TAG_BR_BASE=${TAG_BR_BASE}"
echo "# TAG_BR_FEATURES=${TAG_BR_FEATURES}"
echo "# CI_DST_BRANCHER_NAME=${CI_DST_BRANCHER_NAME}"
echo "# SRC_VERSION=${SRC_VERSION}"
echo "# SRC_REPO_NAME=${SRC_REPO_NAME}"
echo "# SRC_GIT_COMMIT_ID=${SRC_GIT_COMMIT_ID}"
echo "# BUILD_COUNTER=${BUILD_COUNTER}"

function do_src_analysis_nodejs()
{
    echo "$FUNCNAME"
    echo "TODO"
}

function do_src_analysis_java()
{
   echo "$FUNCNAME"
}
function do_src_analysis()
{
    echo "$FUNCNAME"
    echo "ENABLE_SONAR=${ENABLE_SONAR}"

    case ${SRC_TYPE} in
        nodejs)
            echo "nodejs,"
            do_src_analysis_nodejs
            ;;
        java)
            echo "java,"
            do_src_analysis_java
            ;;
        python)
            echo "python, not support yet"
            ;;
        go)
            echo "go, not support yet"
            ;;
        c)
            echo "c/c++, not support yet"
            ;;
        *)
            echo "not support yet"
            ;;
    esac
}
function do_branch_jone_merge() {
    echo "##########################################"
    echo "分支集成开始："
    echo "从生产环境对应的基线分支${BR_BASELINE} 检出 ${CI_DST_BRANCHER_NAME}"
    prev_br=${BR_BASELINE}
    set +e
    git checkout -f ${BR_BASELINE} >/dev/null
    git checkout -B ${CI_DST_BRANCHER_NAME}
    set -e
    for br in ${BRS_FEATURE[*]};do
        if [[ ${JONE_RUN_ENV} =~ "prd" ]];then
            echo "部署prd 生产只能由默认基线分支(master)部署，不允许选择任何特性分支"
            echo "特性分支只能先部署到uat, 并将自动生成的uat集成分支人工合并到master, 再部署到prd生产"
            exit 1
        fi
        F_COMMITID=$(git rev-parse ${br})
        echo "临时合并feature分支 ${br} ${F_COMMITID}"
        set +e
        git merge --no-edit -s recursive -Xignore-space-at-eol --no-ff ${F_COMMITID} 2>&1
        rv=$?
        set -e
        if [[ ${rv} -ne 0 ]];then
          echo "冲突内容如下:"
          git diff | cat
          echo -e "\n\n\n"
          echo "多个特性分支冲突解决建议："
          echo "修改冲突的文件的人拉在一起沟通一下，由某一个人汇总修改，修改好了后发给所有需要修改这个文件的人，都提交一遍自己的分支，这样就不会冲突了"
          echo "场景举例：多个特性分支，每个特性都要修改pom.xml 容易冲突。比较好的处理办法是：这种情况多个feature分支的人沟通一下，由某一个人改好pom.xml，发个各个feature分支的人都提交一遍就不会冲突了。"
          echo -e "\n\n"
          echo "多个特性分支开发工程实践建议: "
          echo "1. 冲突避免: 两个新特性实现, 代码修设法体现成两个目录、两个文件。尽量避免修改同个文件"
          echo "2. 冲突避免：避免修改同个文件的，尽量两个特性之间不同方法。"
          echo "3. 必须要修改同一个文件同一行的，多沟通，最好由其中一个人修改好,各个分支提交一遍"
          echo -e  "\n\n\n"
          echo "和master冲突解决参考命令# "
          echo "git checkout ${F_COMMITED}"
          echo "git merge ${BR_BASELINE}"
          echo "解决冲突"
          echo "git commit"
          echo "git push"
          exit 1
        fi
    done
    echo "分支集成完毕"
    echo "你本次部署到 ${JONE_RUN_ENV} 的应用将是 ${BR_BASELINE}分支 先后合入 ${BRS_FEATURE[*]}分支的代码编译出来的镜像"
    echo "##########################################"
    echo -e '\n\n'
    set +e
    git --no-pager log --graph --first-parent --oneline -n10 --branches="feature/*" --remotes="origin"  ${CI_DST_BRANCHER_NAME}
    set -e
    echo -e '\n\n'
    SRC_GIT_COMMIT_ID="$(cd ${SRC_TOP};git rev-parse --short HEAD )"
    
}
#        
function do_artifact_build_nodejs()
{
    echo "$FUNCNAME"
}
function do_artifact_build_java()
{
    echo "$FUNCNAME"
    if [[ ${ENABLE_SONAR} -ne 0 ]];then
        if [[ ${PWD_HAVE_DOT_GIT} -eq 1 ]];then
            SONAR_KEY="$(git config --get remote.origin.url | perl -ne 's|https?://(.+)|\1|g;print'| tr -d ':'| tr / .)"
        else
            SONAR_KEY="$(echo $(basename ${CI_PROJECT_PATH})| tr / .)"
        fi
        SONAR_OPT="sonar:sonar -Dsonar.projectKey=${SONAR_KEY} -Dsonar.projectName=$(basename ${SRC_TOP}) -Dsonar.branch.name=$(echo ${JONE_BRANCH_FEATRUE:-master} |tr '/' '-'| tr ',' '-') -Dsonar.ws.timeout=30"
    else
        SONAR_OPT=""
    fi
    echo SONAR_OPT=${SONAR_OPT}
    if [[ ${ARTIFACT_DEPLOY} -gt 0 ]];then
        mvn clean package deploy ${SONAR_OPT} ${S2I_MVN_OPT} -D maven.test.skip=true -U
        exit 0
    else
        set +e
        mvn clean package ${SONAR_OPT} ${S2I_MVN_OPT} -U -D maven.test.skip=true
        rv=$?
        set -e
        if [[ ${rv} -ne 0 ]];then mvn package -U ${SONAR_OPT} ${S2I_MVN_OPT} -D maven.test.skip=true;fi
    fi
    set +e
    mvn dependency:tree -DoutputFile=java-dependency-tree.txt
    echo -e "\n\n\n"
    cat java-dependency-tree.txt
    egrep spring-boot-actuator java-dependency-tree.txt >/dev/null 2>&1
    rv=$?
    if [[ ${rv} -eq 0 ]] ;then
      export SPRING_BOOT_ACTUATOR=1
    else
      export SPRING_BOOT_ACTUATOR=0
      echo "Cant find actuator on dependency, Please enable spring-boot-actuator!"
    fi
    set -e
}
function do_artifact_build()
{
    echo "$FUNCNAME"
    if [[ ${ARTIFACT_DEPLOY} -gt 0 ]];then
        ARTIFACT_DEPLOY=1
    else
        ARTIFACT_DEPLOY=0
    fi
    echo "NEXUS_REPO=${NEXUS_REPO}"
    echo "NEXUS_RELEASE=${NEXUS_RELEASE}"
    echo "ARTIFACT_DEPLOY=${ARTIFACT_DEPLOY}"

    do_branch_jone_merge
    case ${SRC_TYPE} in
        nodejs)
            do_artifact_build_nodejs
            ;;
        java)
            do_artifact_build_java
            ;;
        python)
            echo "not support yet"
            ;;
        go)
            echo "not support yet"
            ;;
        *)
            echo "not support source, or detect fail, commit your build script to ${CI_PROJECT_PATH}/build.sh"
            ;;
    esac
}

function do_docker_get_imgurl_by_dockerfile()
{
    echo "$FUNCNAME"
    if [[ ! -f .dockerignore ]];then
      echo ".git" > .dockerignore
    fi
    DOCKER_THIS_DOCKERFILE=$(realpath $1)

    echo "DOCKER_THIS_DOCKERFILE=${DOCKER_THIS_DOCKERFILE}"
    if [[ -z ${DOCKER_THIS_DOCKERFILE} ]];then
        echo "can't detect Dockerfile"
        exit 1
    fi
    DOCKERFILE_DIR=$(realpath $(dirname ${DOCKER_THIS_DOCKERFILE}))


    if [[ "" == "${DOCKER_REPO}" ]];then
        DOCKER_REPO=${DOCKER_REPO:-harbor.benload.com}
    fi
    if [[ "" == "${DOCKER_NS}" ]];then
    DOCKER_NS=${DEFAULT_NS}
    fi
    if [[ "" == "${DOCKER_NS}" ]];then
    DOCKER_NS="default"
    fi


    if [[ "${DOCKER_THIS_DOCKERFILE}" =~ "." ]];then
      # got bld if dockerfile name is /path/to/Dockerfile.bld
      DOCKER_TAG_SUFFIX=$(echo "${DOCKER_THIS_DOCKERFILE}" | tr '[A-Z]' '[a-z]' | perl -ni -e 's/dockerfile.?(.*)/\1/g;print')
      DOCKER_TAG_DIGIST=$(sha256sum ${DOCKER_THIS_DOCKERFILE} | cut -c -5)
      DOCKER_IMG_TAG=${CI_DST_BRANCHER_NAME}-${DOCKER_TAG_SUFFIX}-${DOCKER_TAG_DIGIST}
      K8S_SVCNAMES=${K8S_SVCNAMES:-${SRC_REPO_NAME}}
    else
      if [[ "${DOCKERFILE_DIR}" == "${CI_PROJECT_PATH}" ]];then
          DOCKER_TAG_SUFFIX=${DOCKER_TAG_SUFFIX:-""}
          DOCKER_IMG_TAG=${TAG_BR_BASE}${TAG_BR_FEATURES}${DOCKER_TAG_SUFFIX}
          K8S_SVCNAMES=${K8S_SVCNAMES:-${SRC_REPO_NAME}}
      else
          DOCKER_TAG_SUFFIX=${DOCKER_TAG_SUFFIX:-$(basename ${DOCKERFILE_DIR})}
          DOCKER_IMG_TAG=${TAG_BR_BASE}${TAG_BR_FEATURES}${DOCKER_TAG_SUFFIX}
          K8S_SVCNAMES=${K8S_SVCNAMES:-$(basename ${DOCKERFILE_DIR})}
      fi
    fi
    DOCKER_IMG_TAG=$(echo ${DOCKER_IMG_TAG} | tr '/' '-')

    DOCKER_URL_1=${DOCKER_REPO}/${DOCKER_NS}/${UNSTABLE}${SRC_REPO_NAME}:${DOCKER_IMG_TAG}
    # all img push to test with diff tag, because should have testing, then retag after tested
    DOCKER_URL_2=${DOCKER_REPO}/${DOCKER_NS}/test:${SRC_REPO_NAME}-${DOCKER_IMG_TAG}
    DOCKER_URL_METHOD=${DOCKER_URL_METHOD:-${DOCKER_URL_METHOD:-1}} #default compatibility
    if [[ ${DOCKER_URL_METHOD} -eq 1 ]];then
      DOCKER_URL=${DOCKER_URL_1}
    elif [[ ${DOCKER_URL_METHOD} -eq 2 ]];then
      DOCKER_URL=${DOCKER_URL_2}
    fi
    DOCKER_SVC_PORTS=$(egrep EXPOSE -i ${DOCKER_THIS_DOCKERFILE}|egrep -v '#' |awk '{print $2}'| awk '{for(i=1;i<=NF;i++){printf "%s,", $i}}' |   perl -ne 's/(.+)\,$/\1/g;print' )

    if [[ -z ${DOCKER_SVC_PORTS} ]];then
        echo "NO EXPOSE in ${DOCKERFILE}"
        DOCKER_SVC_PORTS=""
    fi
    DOCKER_URL_LATEST=$(echo ${DOCKER_URL} |perl -ni -e '{s|(.+):.+|\1:latest|;print}' )
    DOCKER_URL_LATEST_BRANCH=$(echo ${DOCKER_URL} |perl -ni -e "{s|(.+):.+|\1:latest-$(echo ${CI_DST_BRANCHER_NAME} | tr -d '/')|;print}")

    echo "# DOCKER_SVC_PORTS=${DOCKER_SVC_PORTS}"
    echo "# DOCKER_THIS_DOCKERFILE=${DOCKER_THIS_DOCKERFILE}"
    echo "# DOCKERFILE_DIR=${DOCKERFILE_DIR}"
    echo "# DOCKER_REPO=${DOCKER_REPO}"
    echo "# DOCKER_NS=${DOCKER_NS}"
    echo "# DOCKER_TAG_SUFFIX=${DOCKER_TAG_SUFFIX}"
    echo "# DOCKER_IMG_TAG=${DOCKER_IMG_TAG}"

    echo "# DOCKER_URL_1=${DOCKER_URL_1}"
    echo "# DOCKER_URL_2=${DOCKER_URL_2}"
    echo "# DOCKER_URL_METHOD=${DOCKER_URL_METHOD}"
    echo "# DOCKER_URL=${DOCKER_URL}"
    echo "# DOCKER_URL_LATEST=${DOCKER_URL_LATEST}"
    echo "##########################################"
    set +e
    echo ${DOCKER_URL} > docker-url.txt
    set -e
}

function do_docker_build_by_dockerfile()
{
  if [[ $# -eq 0 ]];then
      echo "Error, do_docker_build_by_dockerfile /path/to/dockerfile "
      exit 1
  fi
  if [[ -z ${DOCKER_BUILD} ]];then
      DOCKER_BUILD=1
  fi
  if [[ ${DOCKER_BUILD:-0} -eq 0 ]];then
      echo "DOCKER_BUILD=${DOCKER_BUILD}, exit 0"
      exit 0
  fi
  local DOCKERFILE="${1}"
  do_docker_get_imgurl_by_dockerfile ${DOCKERFILE}

  DOCKER_IMG_EXIST_CHK=${DOCKER_IMG_EXIST_CHK:-0}
  if [[  ${DOCKER_IMG_EXIST_CHK} -ne 0 ]];then
    set +e
    echo "# check img existing for ${DOCKER_URL}, will not do docker build if existed"
    docker pull ${DOCKER_URL}
    rv=$?
    set -e
    if [[ ${rv} -eq 0 ]];then
      echo "# ${DOCKER_URL} check exist!, ignore docker build "
      echo "# export DOCKER_IMG_EXIST_CHK=0 to disable check "
      return
    fi
  fi

  docker build ${S2I_DOCKER_OPT} --pull -f ${DOCKERFILE} -t ${SRC_REPO_NAME}:x${BUILD_COUNTER} ${DOCKERFILE_DIR}

  docker tag ${SRC_REPO_NAME}:x${BUILD_COUNTER} ${DOCKER_URL}
  docker tag ${SRC_REPO_NAME}:x${BUILD_COUNTER} ${DOCKER_URL_LATEST}
  docker tag ${SRC_REPO_NAME}:x${BUILD_COUNTER} ${DOCKER_URL_LATEST_BRANCH}
  set +e
  docker push ${DOCKER_URL}
  rv=$?
  set -e
  # failed ,maybe not login, try login
  if [[ ${rv} -ne 0 ]];then
    echo "try docker login ${DOCKER_URL}"
    docker login -u "${DOCKER_USER}" -p  "${DOCKER_PASS}" ${DOCKER_REPO}/${DOCKER_NS}
    docker push ${DOCKER_URL}
  fi
  set +e
  docker push ${DOCKER_URL_LATEST}
  docker push ${DOCKER_URL_LATEST_BRANCH}
  docker rmi ${DOCKER_URL}
  docker rmi ${DOCKER_URL_LATEST}
  docker rmi ${DOCKER_URL_LATEST_BRANCH}
  set -e

  #report
  echo ${DOCKER_URL} > ${S2I_REPORT_DIR}/s2i.${CI_JOB_STAGE}.${SRC_REPO_NAME}.${DOCKER_SUBDIR_NAME}.${DOCKER_SVC_PORTS}.img.txt

  set +e
  docker rmi ${SRC_REPO_NAME}:x${BUILD_COUNTER}
  set -e
  echo -e "\n\n"
}
function do_deploy_k8s_by_dockerfile()
{
    echo "$FUNCNAME"
  if [[ $# -eq 0 ]];then
      echo "Error, usage: $FUNCNAME /path/to/dockerfile "
      exit 1
  fi
    local dockerfile=${1}

    do_docker_get_imgurl_by_dockerfile ${dockerfile}

    if [[ -z ${K8S_AUTOCD} ]];then
        K8S_AUTOCD=1
    fi
    if [[ -z ${K8S_NS} ]];then
        K8S_NS=${DEFAULT_NS}${K8S_NS_SUFFIX}
    fi
    if [[ -z ${K8S_NS} ]];then
        K8S_NS=default${K8S_NS_SUFFIX}
    fi
    if [[ -z ${K8S_DOMAIN_INTERNAL} ]];then
        K8S_DOMAIN_INTERNAL="bu5-idc.k8s.cd"
    fi
    if [[ -z ${K8S_DOMAIN_PUBLIC} ]];then
        K8S_DOMAIN_PUBLIC="bu5-idc.benload.com"
    fi

    if [[ -n ${K8S_KUBECONFIG} ]];then
        echo "custom kubeconfig, get from K8S_KUBECONFIG"
        export KUBECONFIG=${K8S_KUBECONFIG}
    elif [[ -n ${KUBECONFIG} ]];then
        echo "custom kubeconfig, get from KUBECONFIG"
        export KUBECONFIG=${KUBECONFIG}
    else
        export KUBECONFIG="${HOME}/.kube/config"
        echo "default kubeconfig"
    fi

    if [[ ! -f ${KUBECONFIG} ]] && [[ -n ${K8S_KUBECONFIG_BASE64} ]];then
      mkdir -p $(dirname ${KUBECONFIG})
      echo ${K8S_KUBECONFIG_BASE64} |base64 --ignore-garbage --decode > ${KUBECONFIG} 2>/dev/null
    fi
    set +e
    if [[ -e java-dependency-tree.txt ]];then
      egrep spring-boot-actuator java-dependency-tree.txt >/dev/null 2>&1
      rv=$?
      if [[ ${rv} -eq 0 ]];then
        export SPRING_BOOT_ACTUATOR=1
      else
        export SPRING_BOOT_ACTUATOR=0
        echo "Cant find actuator on dependency, Please enable spring-boot-actuator!"
      fi
    fi
    set -e
    echo "K8S_AUTOCD=${K8S_AUTOCD}"
    echo "K8S_NS=${K8S_NS}"
    echo "K8S_SVCNAMES=${K8S_SVCNAMES}"
    echo "DEPLOY_SUFFIX=${DEPLOY_SUFFIX}"
    echo "K8S_KUBECONFIG=${K8S_KUBECONFIG}"
    echo "K8S_DOMAIN_INTERNAL=${K8S_DOMAIN_INTERNAL}"
    echo "K8S_DOMAIN_PUBLIC=${K8S_DOMAIN_PUBLIC}"
    echo "SPRING_BOOT_ACTUATOR=${SPRING_BOOT_ACTUATOR}"
    echo "##########################################"

    kubectl get node
    kubectl cluster-info
    ### ensure ns exists
    set +e
    kubectl get ns ${K8S_NS}
    rv=$?
    set -e
    if [[ ${rv} -ne 0 ]];then
        echo kubectl create  namespace ${K8S_NS}
        echo "Error, namespace ${K8S_NS} not exist"
        exit 1
    fi

    if [ ${K8S_AUTOCD} -gt 0 ];then
        for SVCNAME in ${K8S_SVCNAMES};do
            set -x
            bash ${SCRIPT_DIR}/k8s-app-import ${DOCKER_URL} ${SVCNAME} ${K8S_NS} "${DOCKER_SVC_PORTS}" ${K8S_AUTOCD} ${K8S_DOMAIN_INTERNAL} ${K8S_DOMAIN_PUBLIC}
            set +x
            #report
            set +e
#            kubectl -n ${K8S_NS} set env deployment/${SVCNAME} JAVA_TOOL_OPTIONS=-Dspring.profiles.active=${K8S_NS}
#             kubectl -n ${K8S_NS} set env deployment/${SVCNAME} --keys=JAVA_TOOL_OPTIONS --from=configmap/java-tool-options
#             kubectl -n ${K8S_NS} set env deployment/${SVCNAME} --keys=APM_JAR --from=configmap/java-tool-options
#             kubectl -n ${K8S_NS} set env deployment/${SVCNAME} --keys=APM_COLLECTOR --from=configmap/java-tool-options
#             if [[ ${SRC_TYPE} == "java" ]];then
#               kubectl patch -n ${K8S_NS} deployment/${SVCNAME} --type='json' -p \
#                 '[{"op":"add","path":"/spec/template/spec/containers/0/volumeMounts", "value": [{"mountPath": "/host/run/skywalking-agent","name": "apm-agent"}]}, {"op":"add","path":"/spec/template/spec/volumes", "value": [{"hostPath": {"path": "/run/skywalking-agent", "type": "" }, "name": "apm-agent"}]}]'
#             fi
            kubectl get ingress -n ${K8S_NS} |egrep ${SVCNAME} 2>/dev/null
            rv=$?
            set -e
        done
    else
        echo "K8S_AUTOCD=${K8S_AUTOCD}, do nothing"
    fi
}
function do_docker_action()
{
    echo "$FUNCNAME"
    local action=all
    if [[ $# -gt 0 ]];then
       action=$1
    fi


    echo "Detect Dockerfile"
    #DETECT_DOCKERFILE="find ${SRC_TOP}   -maxdepth 1 -iname Dockerfile | sort"
    if [[ ${S2I_MUTI_DOCKERFILE} -gt 0 ]];then
      DETECT_DOCKERFILE="find ${SRC_TOP} -maxdepth 1 -type f  -regextype posix-egrep -iregex '.*Dockerfile.*'"
    else
      DETECT_DOCKERFILE="find ${SRC_TOP} -maxdepth 1 -type f  -regextype posix-egrep -iregex '.*Dockerfile'"
    fi
    eval ${DETECT_DOCKERFILE}
    eval ${DETECT_DOCKERFILE} | while read d;do
        if [[ -n $(eval ${DETECT_DOCKERFILE}) ]];then
            DOCKERFILE=$(realpath "${d}")
        else
            echo "can't detect Dockerfile"
            exit 0
        fi
        echo "########################################## ${ACTION_STAGE}"
        do_docker_get_imgurl_by_dockerfile ${DOCKERFILE}
        case ${action} in
            docker)
                do_docker_build_by_dockerfile ${DOCKERFILE}
                ;;
            deploy)
                do_deploy_k8s_by_dockerfile ${DOCKERFILE}
                ;;
            all)
                do_docker_build_by_dockerfile ${DOCKERFILE}
                do_deploy_k8s_by_dockerfile ${DOCKERFILE}
                ;;
            *)
                ;;
        esac
    done
}



function s2i_metric()
{
  set +e
  which metric-util-lib >/dev/null 2>&1
  rv=$?
  if [[ ${rv} -eq 0 ]];then
    set -o allexport; source metric-util-lib >/dev/null 2>&1;set +o allexport
  fi

  set -e
}

trap "s2i_metric" INT QUIT TERM EXIT

if [[ -z ${S2E_CALLED_TIME} ]];then
  S2E_CALLED_TIME=$(stat -c%X /proc/"$$")
fi
export S2E_CALLED_TIME
export SRC_TOP
# main logic
###################################################################


case ${ACTION_STAGE} in
    anal*)
        do_src_analysis
        ;;
    art*)
        do_artifact_build
        ;;
    docker)
        do_docker_action docker
        ;;
    deploy)
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_docker_action deploy
        ;;
    deploy-update-default)
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_docker_action deploy
        ;;
    deploy-update-blue)
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=0
        export DEPLOYMENT_BLUE=1
        do_docker_action deploy
        ;;
    deploy-insert-default)
        export DEPLOYMENT_UPDATE_IMG=0
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_docker_action deploy
        ;;
    ACTION_ALL*)
        do_artifact_build
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_docker_action docker
        ;;
    help*)
        echo "${USAGE}"
        ;;
    exec)
        shift 2
        set +e
        which $1 >/dev/null 2>&1
        rv=$?
        set -e
        if [[ $rv -ne 0 ]];then
          echo "Error, $1 cmd not exist in PATH"
          exit 1
        else
          echo "OK, try exec $@ , CMD = $@ $(which $1)"
          exec $@
        fi
        ;;
    *)
        echo "unkown action"
        ;;
esac
set +e

do_docker_get_imgurl_by_dockerfile ./Dockerfile
    set +e
    if [[ -e java-dependency-tree.txt ]];then
      egrep spring-boot-actuator java-dependency-tree.txt >/dev/null 2>&1
      rv=$?
      if [[ ${rv} -eq 0 ]];then
        export SPRING_BOOT_ACTUATOR=1
      else
        export SPRING_BOOT_ACTUATOR=0
        echo "Cant find actuator on dependency, Please enable spring-boot-actuator!"
      fi
    fi
    set -e
# 前端强制启用健康检查
if [[ ${SRC_TYPE} == "nodejs" ]];then
  export SPRING_BOOT_ACTUATOR=1
fi
if [[ ${ACTION_STAGE} =~ "ACTION_ALL" || ${ACTION_STAGE} =~ "deploy" ]];then
       # dev
  if [[  "${JONE_RUN_ENV}" =~ "dev" ]];then
        do_docker_action deploy
        if [[ ${SRC_TYPE} == "java" ]] || [[ ${SRC_TYPE} == "nodejs" ]] ;then
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=JAVA_TOOL_OPTIONS --from=configmap/java-tool-options
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=APM_JAR --from=configmap/java-tool-options
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=APM_COLLECTOR --from=configmap/java-tool-options
          kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
            "[{'op':'add','path':'/spec/template/spec/containers/0/volumeMounts', 'value': [{'mountPath': '/host/run/skywalking-agent','name': 'apm-agent'},{'mountPath': '/cfg/','name': "$K8S_SVCNAMES"}]}, {'op':'add','path':'/spec/template/spec/volumes', 'value': [{'hostPath': {'path': '/run/skywalking-agent', 'type': '' }, 'name': 'apm-agent'},{'configMap': {'defaultMode': 421, 'name': "$K8S_SVCNAMES"}, 'name': "$K8S_SVCNAMES"}]}]"
            CHECK_PORT=$(kubectl get -n ${K8S_NS} svc/${K8S_SVCNAMES} -o=jsonpath='{.spec.ports[0].targetPort}')
           if [[ ${SPRING_BOOT_ACTUATOR} -ne 0 ]] && [[ -n ${CHECK_PORT} ]];then
             kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
             "[{'op':'add','path':'/spec/template/spec/containers/0/livenessProbe', 'value': {'failureThreshold':10,'httpGet':{'httpHeaders':[{'name':'User-Agent','value':'s2i-health-check'}],'path':'/actuator/health','port':${CHECK_PORT},'scheme':'HTTP'},'initialDelaySeconds':15,'periodSeconds':10,'successThreshold':1,'timeoutSeconds':3}}, {'op':'add','path':'/spec/template/spec/containers/0/readinessProbe', 'value': {'failureThreshold':20,'httpGet':{'httpHeaders':[{'name':'User-Agent','value':'s2i-health-check'}],'path':'/actuator/health','port':${CHECK_PORT},'scheme':'HTTP'},'initialDelaySeconds':15,'periodSeconds':10,'successThreshold':1,'timeoutSeconds':3}}]"
             kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
             "[{'op':'add','path':'/spec/template/metadata/annotations', 'value': {'prometheus.io/path':'/actuator/prometheus','prometheus.io/port':\"${CHECK_PORT}\",'prometheus.io/scrape':'true'}}]"
           fi
        fi
  fi
       set +x
  if [[  "${JONE_RUN_ENV}" =~ "test" ]];then
       # test env
        export K8S_NS=lxc-test
        export KUBECONFIG=/root/.kube/test.config
        export K8S_DOMAIN_INTERNAL=xd-scrm-test.nxengine.com
        export DEPLOYMENT_UPDATE_IMG=0
        if [[  "${JONE_RUN_ENV}" =~ "test" ]];then
        export DEPLOYMENT_UPDATE_IMG=1
        fi
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_docker_action deploy
        if [[ ${SRC_TYPE} == "java" ]] || [[ ${SRC_TYPE} == "nodejs" ]] ;then
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=JAVA_TOOL_OPTIONS --from=configmap/java-tool-options
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=APM_JAR --from=configmap/java-tool-options
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=APM_COLLECTOR --from=configmap/java-tool-options
          kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
            "[{'op':'add','path':'/spec/template/spec/containers/0/volumeMounts', 'value': [{'mountPath': '/host/run/skywalking-agent','name': 'apm-agent'},{'mountPath': '/cfg/','name': "$K8S_SVCNAMES"}]}, {'op':'add','path':'/spec/template/spec/volumes', 'value': [{'hostPath': {'path': '/run/skywalking-agent', 'type': '' }, 'name': 'apm-agent'},{'configMap': {'defaultMode': 421, 'name': "$K8S_SVCNAMES"}, 'name': "$K8S_SVCNAMES"}]}]"
            CHECK_PORT=$(kubectl get -n ${K8S_NS} svc/${K8S_SVCNAMES} -o=jsonpath='{.spec.ports[0].targetPort}')
           if [[ ${SPRING_BOOT_ACTUATOR} -ne 0 ]] && [[ -n ${CHECK_PORT} ]];then
             kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
             "[{'op':'add','path':'/spec/template/spec/containers/0/livenessProbe', 'value': {'failureThreshold':10,'httpGet':{'httpHeaders':[{'name':'User-Agent','value':'s2i-health-check'}],'path':'/actuator/health','port':${CHECK_PORT},'scheme':'HTTP'},'initialDelaySeconds':15,'periodSeconds':10,'successThreshold':1,'timeoutSeconds':3}}, {'op':'add','path':'/spec/template/spec/containers/0/readinessProbe', 'value': {'failureThreshold':20,'httpGet':{'httpHeaders':[{'name':'User-Agent','value':'s2i-health-check'}],'path':'/actuator/health','port':${CHECK_PORT},'scheme':'HTTP'},'initialDelaySeconds':15,'periodSeconds':10,'successThreshold':1,'timeoutSeconds':3}}]"
             kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
             "[{'op':'add','path':'/spec/template/metadata/annotations', 'value': {'prometheus.io/path':'/actuator/prometheus','prometheus.io/port':\"${CHECK_PORT}\",'prometheus.io/scrape':'true'}}]"
           fi
        fi
  fi
#         kubectl -n ${K8S_NS} set resources deployment ${K8S_SVCNAMES} --limits=memory=2048Mi --requests=cpu=400m,memory=1600Mi
  if [[  "${JONE_RUN_ENV}" =~ "uat" ]];then
         # uat env
        export K8S_NS=lxc-uat
        export KUBECONFIG=/root/.kube/uat.config
        export K8S_DOMAIN_INTERNAL=xd-scrm-uat.nxengine.com
        export DEPLOYMENT_UPDATE_IMG=0
        if [[  "${JONE_RUN_ENV}" =~ "uat" ]];then
        export DEPLOYMENT_UPDATE_IMG=1
        fi
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        do_docker_action deploy
        if [[ ${SRC_TYPE} == "java" ]] || [[ ${SRC_TYPE} == "nodejs" ]] ;then
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=APM_JAR --from=configmap/java-tool-options
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=APM_COLLECTOR --from=configmap/java-tool-options
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=JAVA_TOOL_OPTIONS --from=configmap/java-tool-options
          kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
            "[{'op':'add','path':'/spec/template/spec/containers/0/volumeMounts', 'value': [{'mountPath': '/host/run/skywalking-agent','name': 'apm-agent'},{'mountPath': '/cfg/','name': "$K8S_SVCNAMES"}]}, {'op':'add','path':'/spec/template/spec/volumes', 'value': [{'hostPath': {'path': '/run/skywalking-agent', 'type': '' }, 'name': 'apm-agent'},{'configMap': {'defaultMode': 421, 'name': "$K8S_SVCNAMES"}, 'name': "$K8S_SVCNAMES"}]}]"
        fi
#         kubectl -n ${K8S_NS} set resources deployment ${K8S_SVCNAMES} --limits=memory=2048Mi --requests=cpu=400m,memory=1600Mi
  fi
  if [[  "${JONE_RUN_ENV}" =~ "prd" ]];then
       # beta
        export K8S_NS=lxc-beta
        export KUBECONFIG=/root/.kube/.scrm-prd/scrm-prd-tke.config
        export INGRESS_INTERNAL_ENABLED=0
        export INGRESS_PUBLIC_ENABLED=0
        export K8S_DOMAIN_INTERNAL=xd-scrm-beta.nxengine.com
        export DEPLOYMENT_UPDATE_IMG=1
        export DEPLOYMENT_DEFAULT=1
        export DEPLOYMENT_BLUE=0
        set +x
        do_docker_action deploy
        set -x
        kubectl -n ${K8S_NS} scale --replicas=0  deployment/${K8S_SVCNAMES}
        if [[ ${SRC_TYPE} == "java" ]] || [[ ${SRC_TYPE} == "nodejs" ]] ;then
          # config source inject
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=JAVA_TOOL_OPTIONS --from=configmap/java-tool-options
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=APM_JAR --from=configmap/java-tool-options
          kubectl -n ${K8S_NS} set env deployment/${K8S_SVCNAMES} --keys=APM_COLLECTOR --from=configmap/java-tool-options
          # apm inject
          kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
            "[{'op':'add','path':'/spec/template/spec/containers/0/volumeMounts', 'value': [{'mountPath': '/host/run/skywalking-agent','name': 'apm-agent'},{'mountPath': '/cfg/','name': "$K8S_SVCNAMES"}]}, {'op':'add','path':'/spec/template/spec/volumes', 'value': [{'hostPath': {'path': '/run/skywalking-agent', 'type': '' }, 'name': 'apm-agent'},{'configMap': {'defaultMode': 421, 'name': "$K8S_SVCNAMES"}, 'name': "$K8S_SVCNAMES"}]}]"
          # health check inject
            CHECK_PORT=$(kubectl get -n ${K8S_NS} svc/${K8S_SVCNAMES} -o=jsonpath='{.spec.ports[0].targetPort}')
           if [[ ${SPRING_BOOT_ACTUATOR} -ne 0 ]] && [[ -n ${CHECK_PORT} ]];then
             kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
             "[{'op':'add','path':'/spec/template/spec/containers/0/livenessProbe', 'value': {'failureThreshold':10,'httpGet':{'httpHeaders':[{'name':'User-Agent','value':'s2i-health-check'}],'path':'/actuator/health','port':${CHECK_PORT},'scheme':'HTTP'},'initialDelaySeconds':15,'periodSeconds':10,'successThreshold':1,'timeoutSeconds':3}}, {'op':'add','path':'/spec/template/spec/containers/0/readinessProbe', 'value': {'failureThreshold':20,'httpGet':{'httpHeaders':[{'name':'User-Agent','value':'s2i-health-check'}],'path':'/actuator/health','port':${CHECK_PORT},'scheme':'HTTP'},'initialDelaySeconds':15,'periodSeconds':10,'successThreshold':1,'timeoutSeconds':3}}]"
             kubectl patch -n ${K8S_NS} deployment/${K8S_SVCNAMES} --type='json' -p \
             "[{'op':'add','path':'/spec/template/metadata/annotations', 'value': {'prometheus.io/path':'/actuator/prometheus','prometheus.io/port':\"${CHECK_PORT}\",'prometheus.io/scrape':'true'}}]"
           fi
        fi
          set +e
#          kubectl -n ${K8S_NS} set resources deployment ${K8S_SVCNAMES} --limits=memory=2048Mi --requests=cpu=900m,memory=2048Mi
          set -e
        set +e
        kubectl -n ${K8S_NS} get  deployment/${K8S_SVCNAMES} -o wide
        rv=$?
        if [[ ${rv} -eq 0 ]];then
          echo "你好，应用${K8S_SVCNAMES} 已部署在beta生产环境"
          echo "beta 环境 "
          echo "请移步 填写发布单，由运维人员手动发布"
        else
           echo "第一次部署应用${K8S_SVCNAMES} 到生产, 将自动部署"
        fi
        set -e
  fi
fi
set -e
set +x
set +e
echo "进行镜像发布"
echo "你本次部署到 ${JONE_RUN_ENV} 的应用 ${K8S_SVCNAMES} 对应的源码是 ${BR_BASELINE}分支为基线 先后合入 ${BRS_FEATURE[*]}分支的代码编译出来的镜像 $(head -n 1 docker-url.txt)"
set -e
RC_NUM=rc09
set +e
#if [[  "${JONE_RUN_ENV}" =~ "test" ]];then
#    set +e
#    echo "进行临时源码发布"
#    RC_NAME=env/test-${RC_NUM}
#    git checkout -b ${RC_NAME}
#    git push origin --delete ${RC_NAME} >/dev/null 2>&1
#    git push --set-upstream origin ${RC_NAME}
#    rv=$?
#    set -e
#    if [[ ${rv} -ne 0 ]];then
#       echo "错误，${RC_NAME} 可能已存在，请移步$(git config remote.origin.url) 删除再重复一遍"
#       exit 1
#    else
#       echo "恭喜，临时集成分支 ${RC_NAME} 已 push 回$(git config remote.origin.url) "
#       echo "可找leader进行代码Review"
#    fi
#fi
#set -e
#set +e
#if [[  "${JONE_RUN_ENV}" =~ "uat" ]];then
#    set +e
#    echo "进行源码发布"
#    RC_NAME=env/uat-${RC_NUM}
#    git checkout -b ${RC_NAME}
#    git push origin --delete ${RC_NAME} >/dev/null 2>&1
#    git push --set-upstream origin  ${RC_NAME} 
#    rv=$?
#    set -e
#    if [[ ${rv} -ne 0 ]];then
#       echo "错误，${RC_NAME} 可能已存在，请移步$(git config remote.origin.url) 删除再重复一遍"
#       exit 1
#    else
#       echo "恭喜，临时集成分支 ${RC_NAME} 已 push 回$(git config remote.origin.url) "
#       echo "请尽快验收，验收通过后，请将${RC_NAME} 尽快合入master"
#    fi
#fi
#if [[  "${JONE_RUN_ENV}" =~ "prd" ]];then
#    set +e
#    echo ""
#    RC_NUM=rc08
#    RC_NAME=release-${RC_NUM}
#    git checkout -b ${RC_NAME}
   # git push origin --delete ${RC_NAME} >/dev/null 2>&1
#    git push --set-upstream origin -f ${RC_NAME}
#    rv=$?
#    set -e
#    if [[ ${rv} -ne 0 ]];then
#       echo "错误，${RC_NAME} 可能已存在，请移步$(git config remote.origin.url) 查看 "
#    else
#       echo "恭喜，新分支 ${RC_NAME} 已 push 回$(git config remote.origin.url) "
#    fi
#fi
#set -e
